Тройка Хоара:

`{arr.length > 0} findMax(arr) {result = max(arr)}`

Возможная реализация функции `findMax`:

```python
def findMax(arr):
    max_value = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > max_value:
            max_value = arr[i]
    return max_value
```

Для доказательства корректности функции определим инвариант цикла и проверим, что он выполняется на каждой итерации.

Инвариант цикла:  
На каждой итерации `i` инвариант утверждает, что `max_value` — это максимальный элемент среди всех элементов массива `arr` от индекса `0` до `i-1`.

Перед первой итерацией (при `i=1`):

Мы инициализируем `max_value` как `arr[0]`. 
Для подмассива из одного элемента, `max(arr[0…0])=arr[0]`, что соответствует значению `max_value`.
Таким образом, инвариант истинный перед началом цикла.

Сохранение инварианта (переход индукции):  
Предположим, что инвариант истинен для некоторого значения `i` (т.е. `max_value` равен максимальному значению в подмассиве `arr[0]` до `arr[i-1]`).

На итерации с индексом `i`:
- Если `arr[i] > max_value`, то обновляется `max_value = arr[i]`, и новый `max_value` теперь является максимальным значением в подмассиве `arr[0...i]`.
- Если `arr[i] <= max_value`, то `max_value` остается прежним и по-прежнему является максимальным значением в `arr[0...i]`.  

**Таким образом, инвариант сохраняется на каждой итерации.**

Завершение (выход из цикла):  
Цикл завершится, когда мы достигнем конца массива (индекс `i = arr.length`). В этот момент инвариант гарантирует, что `max_value` содержит максимальный элемент массива `arr` от `arr[0]` до `arr[len(arr) - 1]`, что соответствует всему массиву.

Постусловие:  
После завершения цикла `max_value` равен максимальному значению в массиве `arr`, что и требовалось доказать.